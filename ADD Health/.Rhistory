table(waves$AdultAttack)
# Adult Destroy Property:
table(waves$H4DS1)
waves <- waves %>%
mutate(AdultDestroyProperty = case_when(
H4DS1 %in% c(6, 8)  ~ NaN,
H4DS1 == 0 ~ 0,
H4DS1 %in% c(1, 2, 3) ~ 1))
table(waves$AdultDestroyProperty)
# Adult Sell Drugs:
# H3DS5 in (1, 2, 3) or H4DS5 in (1, 2, 3) THEN AdultSellDrugs == 1
table(waves$H3DS5)
table(waves$H4DS5)
waves <- waves %>%
mutate(AH3DS5 = case_when(
H3DS5 %in% c(6, 8, 9) ~ NaN,
H3DS5 == 0 ~ 0,
H3DS5 %in% c(1, 2, 3) ~ 1)) %>%
mutate(AH4DS5 = case_when(
H4DS5	%in% c(6, 8) ~ NaN,
H4DS5	== 0 ~ 0,
H4DS5	 %in% c(1, 2, 3) ~ 1)) %>%
mutate(AdultSellDrugs = case_when(
is.na(AH3DS5) & is.na(AH4DS5) ~ NaN,
AH3DS5 == 0 & AH4DS5 == 0 ~ 0,
AH3DS5 == 1 | AH4DS5 == 1 ~ 1,
TRUE ~ NaN))
table(waves$AdultSellDrugs)
# Adult Stolen Credit/ATM Card:
# 1 == if H3DS9 in (1, 2, 3) or H4DS9 in (1, 2, 3)
table(waves$H3DS9)
table(waves$H4DS9)
waves <- waves %>%
mutate(AH3DS9 = case_when( # Wave 3
H3DS9 %in% c(6, 8, 9) ~ NaN,
H3DS9 == 0 ~ 0,
H3DS9 %in% c(1, 2 ,3) ~ 1)) %>%
mutate(AH4DS9 = case_when( # Wave 4
H4DS9 %in% c(6, 8) ~ NaN,
H4DS9 == 0 ~ 0,
H4DS9 %in% c(1, 2, 3) ~ 1)) %>%
mutate(AdultStolenCard = case_when(
is.na(AH3DS9) & is.na(AH4DS9) ~ NaN,
AH3DS9 == 0 & AH4DS9 == 0 ~ 0,
AH3DS9 == 1 | AH4DS9 == 1 ~ 1,
TRUE ~ NaN))
table(waves$AdultStolenCard)
"Creating Generalized Aggressive/Non-Aggressive Crime Variables:"
# Crime:
# AC = Aggressive Crime
# NAC = Non-aggressive Crime
waves <- waves %>%
mutate(ACPhysicalAttack = replace(H4DS11, H4DS11 %in% c(6, 8), NaN)) %>%
mutate(ACGun = AdultGun) %>%
mutate(ACShootStab = AdultShootStab) %>%
mutate(ACAttack = AdultAttack) %>%
mutate(NACOtherProperty1 = replace(H4DS8, H4DS8 %in% c(6, 8), NaN)) %>%
mutate(NACOtherProperty2 = replace(H3DS8, H3DS8 %in% c(6, 8, 9), NaN)) %>%
mutate(NACOtherProperty = NACOtherProperty1 + NACOtherProperty2) %>%
mutate(NACStealLess = replace(H4DS6, H4DS6 %in% c(6, 8), NaN)) %>%
mutate(NACStealMore = replace(H4DS2, H4DS2 %in% c(6, 8), NaN))
table(waves$ACPhysicalAttack)
table(waves$ACGun)
table(waves$ACShootStab)
table(waves$ACAttack)
table(waves$NACOtherProperty)
table(waves$NACStealLess)
table(waves$NACStealMore)
waves <- waves %>%
mutate(AggCrime = ACPhysicalAttack + ACGun + ACShootStab + ACAttack) %>%
mutate(NonAggCrime = NACOtherProperty + NACStealLess + NACStealMore)
table(waves$AggCrime)
table(waves$NonAggCrime)
"Adverse Childhood Experiences:"
# Supervisory Neglect:
table(Waves$HomeAlone)
# Emotional Neglect:
table(waves$H1PF23)
table(waves$H1PF1)
waves <- waves %>%
mutate(aceEmotionalNeglect1 = case_when(
H1PF23 %in% c(6, 7, 8, 9) ~ NaN,
H1PF23 %in% c(4, 5) ~ 0,
TRUE ~ 1)) %>%
mutate(aceEmotionalNeglect2 = case_when(
H1PF1 %in% c(6, 7, 8) ~ NaN,
H1PF1 %in% c(4, 5) ~ 0,
TRUE ~ 1)) %>%
mutate(aceEmotionalNeglect = case_when(
is.na(aceEmotionalNeglect1) & is.na(aceEmotionalNeglect2) ~ NaN,
aceEmotionalNeglect1 == 1 | aceEmotionalNeglect2 == 1 ~ 1,
TRUE ~ 0))
table(waves$aceEmotionalNeglect)
# Physical Abuse:
table(Waves$SlapHitKick)
# Emotional Abuse:
table(Waves$HurtFeelings)
# Sexual Abuse:
table(Waves$Touched)
# Suicidal Attempt of Household Adults:
table(waves$H1SU6)
waves <- waves %>%
mutate(aceSuicide = case_when(
H1SU6 %in% c(6, 8, 9) ~ NaN,
H1SU6 == 0 ~ 0,
H1SU6 == 1 ~ 1))
table(waves$aceSuicide)
# Parental Alcohol Misuse:
table(Waves$BingeDrink)
# Parental Separation/Divorce:
table(Waves$Divorce)
# Household Adult Incarceration:
table(waves$H4WP3)
table(waves$H4WP30)
table(waves$H4WP16)
table(waves$H4WP9)
# Experience in the Foster Care System:
table(Waves$FosterHome)
# Direct Witnessing of Violence:
table(waves$JH1FV1)
# Being the Victim of Violence:
table(waves$JH1FV2)
table(waves$JH1FV3)
table(waves$JH1FV4)
waves <- waves %>%
mutate(aceVictim = case_when(
is.na(JH1FV2) & is.na(JH1FV3) & is.na(JH1FV4) ~ NaN,
JH1FV2 == 1 | JH1FV3 == 1 | JH1FV4 == 1 ~ 1,
TRUE ~ 0))
table(waves$aceVictim)
"Juvenile Incarceration:"
# 0 = No
# 1 = Yes
# NA = Missing/NA
waves <- waves %>%
mutate(JIncarceration = case_when(
H4CJ5 %in% c(996, 998) ~ NA_real_,
H4CJ5 == 997 ~ 0,
H4CJ5 %in% seq(1, 95) ~ 1))
table(waves$JIncarceration)
table(is.na(waves$JIncarceration))
"Adult Incarceration"
# 0 = No
# 1 = Yes
# NA = Missing/NA
waves <- waves %>%
mutate(AIncarceration = case_when(
is.na(H4CJ6) ~ NaN,
H4CJ6 %in% c(96, 98) ~ NA_real_,
H4CJ6 == 97 ~ 0,
H4CJ6 %in% seq(1,90) ~ 1))
table(waves$AIncarceration)
table(is.na(waves$AIncarceration))
#########################
variables <- as.data.frame(names(waves))
#########################
"Select only the necessary variables:"
attach(waves)
Waves <- waves %>%
select(AID, H1GI1Y,
PEducation, Race, Black, Asian, Age, Geography, Gender, Gender.Coded, Hispanic, Citizenship,
EverSuspend, Divorce, JIncarceration, AIncarceration, FirstIncarcAge, TwoParentHome,
P1Education, P2Education, SES, JIncarceMonths, AIncarceMonths, AEmployed,
MotherEmployed, FatherEmployed, Unemployment, MotherHoursWeek, FatherHoursWeek,
MotherOvertime, FatherOvertime, W1Grade, W1GradeLevel, W2Grade, W2GradeLevel,
MiddleDropout, HighDropout, FamilySize, Death, HighestGrade, HighGrade15,
SuspendGrade, ESuspend, MSuspend, HSuspend, Expel, ADPhysicalFight, ADKnifeGun,
ADShootStab, ADWeaponSchool, NADLying, NADShoplift,
NADStealLess, NADStealMore, AtPCloseMother,
AtPCloseFather, AtPMotherCare, AtPFatherCare,
AtSClose, AtSHappy, AtSPartOf, AtSFairly,
AtDPCigs, AtDPAlcohol, AtDPWeed, APEnglish,
APMath, APHistory, APScience, AggDelinq,
NonAggDelinq, AttachParents, AtDelinqPeers, AcadPerform,
JVictim, AVictim, Victim, CantPayBills, BasicNeeds, HomeAlone, SlapHitKick,
Touched, HurtFeelings, BioFatherJail, BioMotherJail, FigFatherJail, FigMotherJail,
BingeDrink, Trauma, Homeless, AStealMore, AStealLess, AStealProperty, ADamageProperty,
AShootStab, APhysicalFight, AKnifeGun, ASellDrugs, FosterHome,
JDDriveDrunk, JDDriveHigh, JDSellDrugs, JDIllegalDrugUse, JDCocaineUse, JDIllegalDrugNeedle,
JDAloneDrugUse, JDFightOnDrugs, JDWeaponOnDrugs, JDStealLess, JDStealMore, JDStealStore,
JDKnifeGun, JDShootStab, JDLying, JDPhysicalFight, JDSeriousPhysicalFight, JDDamageProperty,
JDWeaponFight, JDHurtBadly, JDGraffitPaint, AdultStealMore, AdultStealLess, AdultGun, AdultShootStab,
AdultOtherProperty, AdultPhysicalAttack, AdultAttack, AdultDestroyProperty, AdultSellDrugs,
AdultStolenCard, ACPhysicalAttack, ACGun, ACShootStab, ACAttack, NACOtherProperty, NACStealLess,
NACStealMore, AggCrime, NonAggCrime, aceEmotionalNeglect, aceSuicide, aceVictim, JH1FV1,
aceParentJail)
"Rename some of the variables:"
#New = Old
Waves <- Waves %>%
rename(BirthYear = H1GI1Y,
aceWitnessViolence = JH1FV1)
attach(Waves)
names(Waves)
vars <- data.frame(names(Waves))
Waves <- waves %>%
select(JIncarceration, Victim, Divorce, Gender, Black, Hispanic, Asian) %>%
mutate_if(is.double, as.factor)
rm(wave1)
rm(wave2)
rm(wave3)
rm(wave4)
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('Testing.R')
# Load the ggplot2 package which provides
# the 'mpg' dataset.
library(ggplot2)
ui <- fluidPage(
titlePanel("Basic DataTable"),
# Create a new Row in the UI for selectInputs
fluidRow(
column(4,
selectInput("man",
"Manufacturer:",
c("All",
unique(as.character(mpg$manufacturer))))
),
column(4,
selectInput("trans",
"Transmission:",
c("All",
unique(as.character(mpg$trans))))
),
column(4,
selectInput("cyl",
"Cylinders:",
c("All",
unique(as.character(mpg$cyl))))
)
),
# Create a new row for the table.
DT::dataTableOutput("table")
)
server <- function(input, output) {}
shinyApp(ui, server)
# Load the ggplot2 package which provides
# the 'mpg' dataset.
library(ggplot2)
ui <- fluidPage(
titlePanel("Basic DataTable"),
# Create a new Row in the UI for selectInputs
fluidRow(
column(4,
selectInput("man",
"Manufacturer:",
c("All",
unique(as.character(mpg$manufacturer))))
),
column(4,
selectInput("trans",
"Transmission:",
c("All",
unique(as.character(mpg$trans))))
),
column(4,
selectInput("cyl",
"Cylinders:",
c("All",
unique(as.character(mpg$cyl))))
)
),
# Create a new row for the table.
DT::dataTableOutput("table")
)
server <- function(input, output) {
# Filter data based on selections
output$table <- DT::renderDataTable(DT::datatable({
data <- mpg
if (input$man != "All") {
data <- data[data$manufacturer == input$man,]
}
if (input$cyl != "All") {
data <- data[data$cyl == input$cyl,]
}
if (input$trans != "All") {
data <- data[data$trans == input$trans,]
}
data
}))
}
shinyApp(ui, server)
library(tidyverse) # For the unite and row_number functions
schema <- function(Sites = NULL, NSubjects, RRatio = NULL, NFactors){
### Error-checking: ###
# Unique site codes:
test1 = any(duplicated(Sites))
if (test1 == TRUE){
stop("Error: Please enter unique site codes")
}
# Non-positive number of subjects:
test2 <- any(NSubjects <= 0)
if (test2 == TRUE){
stop("Error: Please enter a positive integer for the number of subjects per site")
}
# Improper Randomization Ratio:
if (is.character(RRatio) == TRUE){
stop("Error: The randomization ratio must be a numeric data type")
}
test3 <- NSubjects*(RRatio/(RRatio+1))%%1 == 0
if (test4 == FALSE){
stop("Error: The randomization ratio must adhere to NSubjects*(RRatio/RRatio+1)")
}
# Improper number of factors:
if (NFactors < 0){
stop("Error: The number of factors must be greater than or equal to 0")
}
# Start with 2 empty data matrices:
matt = matrix(NA, nrow = length(Sites), ncol = NSubjects)
final = matrix(NA, nrow = length(Sites)*NSubjects, ncol = NFactors+1)
# Assign names to each column, otherwise you'll get an error:
dimnames(matt) = list(Sites)
# Assign letters to each subject @ each site:
for (i in Sites){
for (j in NSubjects){
matt[i, ] = rep(i, times = NSubjects) # Row-wise
}
}
# Return the transpose of the matrix:
matt = as.data.frame(t(matt)) # Turn into a dataframe as well
# Adding the numbers to the end via a simple if-then-else statement
for (column in matt){
matt[column, ] = if_else(row_number(column) < 10,
true = paste(column, "0", row_number(column), sep = ""),
false = paste(column, row_number(column), sep = ""))
}
row.names(matt) = NULL # Just for aesthetics, no functional purpose
#Select the first column & rows between [nrow(data) -> NSubjects]:
matt = matt[NSubjects+1:(nrow(matt)-NSubjects), 1]
# Calculating the number of T's and C's:
for (i in (NSubjects+1)){ # +1 because it will drop off at NSubjects otherwise
timesT = NSubjects*(RRatio/(RRatio+1))
timesC = (NSubjects - timesT)
TLC = data.frame(TorC = sample(t(rep(c("T", "C"), times = c(timesT, timesC)))))
}
# Repeat the process above for each site
TLC = data.frame(TorC = rep(TLC$TorC, times = length(Sites)))
# Shuffle the data randomly:
matt = sample(matt)
# Turn the data matrix into a data.frame:
matt = as.data.frame(matt)
# Concatenate both objects into a single dataframe
result = data.frame(c(TLC, matt))
# Use the "unite" function to concatenate both columns into a single column
result = result %>% # using the pipe operator from the dplyr syntax
unite(Codes, c("matt", "TorC"), sep = "")
# For each column, append the result to the previously empty matrix above
for(column in 0:1){
final[, column] <- result[ , 1] # Copy only the first column
}
# Return the end result:
return(final)
}
# Testing:
FINAL <- schema(Sites = c("AAA", "BBB"), NSubjects = 48, RRatio = "2", NFactors = 3)
# Testing:
FINAL <- schema(Sites = c("AAA"), NSubjects = 30, RRatio = 1, NFactors = 3)
# Return the end result:
return(final)
schema <- function(Sites = NULL, NSubjects, RRatio = NULL, NFactors){
### Error-checking: ###
# Unique site codes:
test1 = any(duplicated(Sites))
if (test1 == TRUE){
stop("Error: Please enter unique site codes")
}
# Non-positive number of subjects:
test2 <- any(NSubjects <= 0)
if (test2 == TRUE){
stop("Error: Please enter a positive integer for the number of subjects per site")
}
# Improper Randomization Ratio:
if (is.character(RRatio) == TRUE){
stop("Error: The randomization ratio must be a numeric data type")
}
test3 <- NSubjects*(RRatio/(RRatio+1))%%1 == 0
if (test3 == TRUE){
stop("Error: The randomization ratio must adhere to NSubjects*(RRatio/RRatio+1)")
}
# Improper number of factors:
if (NFactors < 0){
stop("Error: The number of factors must be greater than or equal to 0")
}
# Start with 2 empty data matrices:
matt = matrix(NA, nrow = length(Sites), ncol = NSubjects)
final = matrix(NA, nrow = length(Sites)*NSubjects, ncol = NFactors+1)
# Assign names to each column, otherwise you'll get an error:
dimnames(matt) = list(Sites)
# Assign letters to each subject @ each site:
for (i in Sites){
for (j in NSubjects){
matt[i, ] = rep(i, times = NSubjects) # Row-wise
}
}
# Return the transpose of the matrix:
matt = as.data.frame(t(matt)) # Turn into a dataframe as well
# Adding the numbers to the end via a simple if-then-else statement
for (column in matt){
matt[column, ] = if_else(row_number(column) < 10,
true = paste(column, "0", row_number(column), sep = ""),
false = paste(column, row_number(column), sep = ""))
}
row.names(matt) = NULL # Just for aesthetics, no functional purpose
#Select the first column & rows between [nrow(data) -> NSubjects]:
matt = matt[NSubjects+1:(nrow(matt)-NSubjects), 1]
# Calculating the number of T's and C's:
for (i in (NSubjects+1)){ # +1 because it will drop off at NSubjects otherwise
timesT = NSubjects*(RRatio/(RRatio+1))
timesC = (NSubjects - timesT)
TLC = data.frame(TorC = sample(t(rep(c("T", "C"), times = c(timesT, timesC)))))
}
# Repeat the process above for each site
TLC = data.frame(TorC = rep(TLC$TorC, times = length(Sites)))
# Shuffle the data randomly:
matt = sample(matt)
# Turn the data matrix into a data.frame:
matt = as.data.frame(matt)
# Concatenate both objects into a single dataframe
result = data.frame(c(TLC, matt))
# Use the "unite" function to concatenate both columns into a single column
result = result %>% # using the pipe operator from the dplyr syntax
unite(Codes, c("matt", "TorC"), sep = "")
# For each column, append the result to the previously empty matrix above
for(column in 0:1){
final[, column] <- result[ , 1] # Copy only the first column
}
# Return the end result:
return(final)
}
# Testing:
FINAL <- schema(Sites = c("AAA"), NSubjects = 30, RRatio = 1, NFactors = 3)
schema <- function(Sites = NULL, NSubjects, RRatio = NULL, NFactors){
### Error-checking: ###
# Unique site codes:
test1 = any(duplicated(Sites))
if (test1 == TRUE){
stop("Error: Please enter unique site codes")
}
# Non-positive number of subjects:
test2 <- any(NSubjects <= 0)
if (test2 == TRUE){
stop("Error: Please enter a positive integer for the number of subjects per site")
}
# Improper Randomization Ratio:
if (is.character(RRatio) == TRUE){
stop("Error: The randomization ratio must be a numeric data type")
}
test3 <- NSubjects*(RRatio/(RRatio+1))%%1 == 0
if (test3 == TRUE){
stop("Error: The randomization ratio must adhere to NSubjects*(RRatio/RRatio+1)")
}
# Improper number of factors:
if (NFactors < 0){
stop("Error: The number of factors must be greater than or equal to 0")
}
# Start with 2 empty data matrices:
matt = matrix(NA, nrow = length(Sites), ncol = NSubjects)
final = matrix(NA, nrow = length(Sites)*NSubjects, ncol = NFactors+1)
# Assign names to each column, otherwise you'll get an error:
dimnames(matt) = list(Sites)
# Assign letters to each subject @ each site:
for (i in Sites){
for (j in NSubjects){
matt[i, ] = rep(i, times = NSubjects) # Row-wise
}
}
# Return the transpose of the matrix:
matt = as.data.frame(t(matt)) # Turn into a dataframe as well
# Adding the numbers to the end via a simple if-then-else statement
for (column in matt){
matt[column, ] = if_else(row_number(column) < 10,
true = paste(column, "0", row_number(column), sep = ""),
false = paste(column, row_number(column), sep = ""))
}
row.names(matt) = NULL # Just for aesthetics, no functional purpose
#Select the first column & rows between [nrow(data) -> NSubjects]:
matt = matt[NSubjects+1:(nrow(matt)-NSubjects), 1]
# Calculating the number of T's and C's:
for (i in (NSubjects+1)){ # +1 because it will drop off at NSubjects otherwise
timesT = NSubjects*(RRatio/(RRatio+1))
timesC = (NSubjects - timesT)
TLC = data.frame(TorC = sample(t(rep(c("T", "C"), times = c(timesT, timesC)))))
}
# Repeat the process above for each site
TLC = data.frame(TorC = rep(TLC$TorC, times = length(Sites)))
# Shuffle the data randomly:
matt = sample(matt)
# Turn the data matrix into a data.frame:
matt = as.data.frame(matt)
# Concatenate both objects into a single dataframe
result = data.frame(c(TLC, matt))
# Use the "unite" function to concatenate both columns into a single column
result = result %>% # using the pipe operator from the dplyr syntax
unite(Codes, c("matt", "TorC"), sep = "")
# For each column, append the result to the previously empty matrix above
for(column in 0:1){
final[, column] <- result[ , 1] # Copy only the first column
}
# Turn into a dataframe:
final <- as.data.frame(final)
# Return the end result:
return(final)
}
# Testing:
FINAL <- schema(Sites = c("AAA"), NSubjects = 30, RRatio = 1, NFactors = 3)
View(FINAL)
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
runApp('C:/Users/miqui/OneDrive/Consulting/Randomizations')
rm(list = ls())
