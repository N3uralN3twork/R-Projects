}
b = t(rep(a, each = NSubjects)[seq(1, Sites*NSubjects)])
return(b)
}
result <- test(Sites = 30, NSubjects = 10)
df <- data.frame(Sites = t(result))
View(df)
library(testthat)
sqrt <- function(x){
return(sqrt(x))
}
test_that("Test sqrt function:", {
expected = 2
actual = sqrt(4)
expect_equal(expected, actual)
})
library(testthat)
test_that("Test sqrt function:", {
expected = 2
actual = sqrt_newton(4, 1)
expect_equal(expected, actual)
})
sqrt_newton <- function(a, init, eps = 0.01, iter = 100){
stopifnot(a >= 0)
i <- 1
while(abs(init**2 - a) > eps){
init <- 1/2 *(init + a/init)
i <- i + 1
if(i > iter) stop("Maximum number of iterations reached")
}
return(init)
}
test_that("Test sqrt function:", {
expected = 2
actual = sqrt_newton(4, 1)
expect_equal(expected, actual)
})
test_that("Test sqrt function:", {
expected = c(2, 4, 5)
actual = sqrt_newton(c(4, 16, 25), 1)
expect_equal(expected, actual)
})
test_that("Test sqrt function:", {
expected = c(2, 4, 5)
actual = sqrt_newton(c(4, 16, 25), 1)
expect_equal(expected, actual)
})
library(devtools)
devtools::create("myfirstpackage")
devtools::document()
library(devtools)
install.packages("devtools")
library(devtools)
install.packages("backports")
library(devtools)
install.packages("rlang")
library(Randomizations)
library(rlang)
library(tidyverse) # For the unite and row_number functions
library(devtools)
library(devtools)
library(ggplot2)
ggplot(data = diamonds, aes(x = carat)) +
geom_histogram()
library(Randomizations)
install.packages(c("libcoin", "pbapply", "StanHeaders"))
library(libcoin)
library(ggplot2)
library(Randomizations)
library(dplyr)
library(tidyverse)
install.packages("backports")
library(tidyverse)
library(Randomizations)
Randomizations::schema(Sites = c("AAA", "BBB"), NSubjects = 10, BlockSize = 5, RRatio = 1)
library(Randomizations)
schema(1, 10, 0, 1)
library(Randomizations)
schema(1,10,1,1)
library(Randomizations)
Randomizations::schema(Sites = c("AAA"), NSubjects = 10, BlockSize = NULL, RRatio = 1)
Randomizations::schema(Sites = c("AAA"), NSubjects = 10, BlockSize = NULL, RRatio = 1)
library(tidyverse)
Randomizations::schema(Sites = c("AAA"), NSubjects = 10, BlockSize = NULL, RRatio = 1)
install.packages("C:/Users/miqui/OneDrive/Consulting/Randomizations_1.0.tar.gz", repos = NULL, type = "source")
library(Randomizations)
shiny::runApp('C:/Users/miqui/OneDrive/Consulting/Actual Work')
shinyApp(ui, server)
runApp('C:/Users/miqui/OneDrive/Consulting/Actual Work')
runApp('C:/Users/miqui/OneDrive/Consulting/Actual Work')
runApp('C:/Users/miqui/OneDrive/Consulting/Actual Work')
runApp('C:/Users/miqui/OneDrive/Consulting/Actual Work')
library(Randomizations)
schema(1,10,0,1)
library(Randomizations)
schema <- function(Sites = NULL, NSubjects, BlockSize = NULL, RRatio = NULL, seed = TRUE){
# Set the seed for reproducibility:
if (seed == TRUE){
set.seed(123)}
# Input morphism:
if (is.character(RRatio)){ # If the input is a character ratio
nums = as.integer(unlist(str_split(string = RRatio, pattern = ":"))) # Extract the chars and turn into integers
RRatio = nums[1]/nums[2] # Turn the above ratio into a fraction for later use
}
if (is.character(NSubjects)){
NSubjects = as.integer(NSubjects)
}
if (is.character(BlockSize)){
BlockSize = as.integer(BlockSize)
}
### Error-checking: ###
# Null value for sites:
if (is.null(Sites) == TRUE){
stop("Please enter either an integer or site prefixes")
}
# Unique site codes:
test1 = any(duplicated(Sites))
if (test1 == TRUE){
stop("Please enter unique site codes")
}
# Non-positive number of sites:
if (is.numeric(Sites) && Sites <= 0){
stop("Please enter a valid number of sites (>=1)")
}
# Non-positive number of subjects:
test2 <- any(NSubjects <= 0)
if (test2 == TRUE){
stop("Please enter a positive integer for the number of subjects per site")
}
# Improper Randomization Ratio:
test3 <- NSubjects*(RRatio/(RRatio+1))%%1 == 0
if (test3 == TRUE){
stop("The randomization ratio must adhere to NSubjects*(RRatio/RRatio+1)%%1 = 0")
}
if (RRatio <= 0){
stop("The randomization ratio must be greater than 0")
}
# Improper random seed
"%!in%" = Negate("%in%") # Handy function to include the negation of an IN statement
if (seed %!in% c(TRUE, FALSE)){ # If seed not TRUE or FALSE:
stop("The seed should be a boolean input") # Return this error message
}
# Designing the schema:
# If the input to sites is a NUMERIC number
if (is.numeric(Sites) == TRUE){ # Test if a numeric number
matt = c() # Start with an empty vector
final = matrix(NA, nrow = Sites*NSubjects, ncol = 1) # Add an empty matrix
for (letter in LETTERS){ # For each letter in the uppercase(Alphabet):
result = rep(letter, times = 3) # Repeat each letter 3 times
result = paste(result, collapse = "") # Combine the result into 1 string
matt[letter] = result # Assigns the result to the previously empty vector "matt"
} # Now that we have assigned the letters to the vector "matt"
matt = data.frame(t(matt)) # Transpose "matt"
matt = matt %>% # For each site code in your input:
uncount(NSubjects) # Duplicate the site code NSubjects number of times
matt = matt[1:NSubjects, 1:Sites] # Removing redundant codes
rownames(matt) = NULL
}
# If the input to sites is a CHARACTER vector
else if (is.vector(Sites) == TRUE){
matt = matrix(NA, nrow = length(Sites), ncol = NSubjects)  # Start with an empty data matrix
dimnames(matt) = list(Sites) # Must include or won't run
final = matrix(NA, nrow = length(Sites)*NSubjects, ncol = 1) # Start with an empty data matrix
for (i in Sites){ # For each site:
for (j in NSubjects){ # And for each subject
matt[i, ] = rep(i, times = NSubjects) # Row-wise assignment of letters
}
}
matt = as.data.frame(t(matt)) # Transpose and turn into a dataframe for reasonable viewing
rownames(matt) = NULL # Replace unnecessary rownames
matt = data.frame(matt)
}
# Adding the numbers to the end via a simple if-then-else statement
if (is.numeric(Sites) && Sites == 1){
matt = ifelse(row_number(matt) < 10, # If the row-number is less than 10:
yes = paste(matt, "0", row_number(matt), sep = ""), # Assign a 0 between letter and number
no = paste(matt, row_number(matt), sep = "")) # Otherwise: assign no space between letters and number
row.names(matt) = NULL
matt = data.frame(matt)
}
else { # For all other cases:
for (column in matt){ # For each column in the "matt" matrix
matt[column, ] = if_else(row_number(column) < 10, # Same instructions as above
true = paste(column, "0", row_number(column), sep = ""),
false = paste(column, row_number(column), sep = ""))
}
row.names(matt) = NULL
matt = matt[NSubjects+1:(nrow(matt)-NSubjects), 1] # Only keep the first column and a subset of rows
}
for (i in (NSubjects+1)){ # +1 because it will drop off at NSubjects otherwise
timesT = NSubjects*(RRatio/(RRatio+1)) # Calculates the number of Ts to assign
timesC = (NSubjects - timesT) # Calculates the number of Cs to assign
TLC = data.frame(TorC = sample(t(rep(c("T", "C"), times = c(timesT, timesC))))) # Concatenates and puts into a dataframe
}
# Repeat the process above for each site
# Must assign special cases for 1 dimensional and N>1 dimensional matrices
TLC = data.frame(TorC = rep(TLC$TorC, times = ifelse(is.numeric(Sites),
yes = Sites,
no = length(Sites))))
# Shuffle the data randomly:
matt = sample(matt)
# Turn the data matrix into a data.frame:
matt = as.data.frame(matt)
# Concatenate both objects into a single dataframe
result = data.frame(c(TLC, matt))
# Use the "unite" function to concatenate both columns into a single column
result = result %>% # using the pipe operator from the dplyr syntax
unite(Codes, c("matt", "TorC"), sep = "")
# For each column, append the result to the previously empty matrix above
for(column in 0:1){
final[, column] <- result[ , 1] # Copy only the first column
}
# Turn into a dataframe:
final <- as.data.frame(final)
# Extracting different parts of the codes for easier reading:
final["Code"] = final[, 1]
final["Site"] =  substr(final[, 1], 1, 3) # extract first three letters from code
final["Subject"] =  gsub("[a-zA-Z]+", "", final[, 1]) # remove letters with regex
final["Group"] = substr(final[, 1], nchar(final[, 1]), nchar(final[, 1]))
# Remove the repetitive column:
final = final %>% select(Code, Site, Subject, Group) # Using dplyr's built-in pipe (%>%) operator
# Return the end result:
return(final)
}
test1 <- schema(Sites = c("AAA"), NSubjects = 10, RRatio = "1:1", seed = TRUE)
# install.packages("tidyverse")
library(tidyverse) # For the unite and row_number functions
test1 <- schema(Sites = c("AAA"), NSubjects = 10, RRatio = "1:1", seed = TRUE)
test2 <- schema(Sites = 1, NSubjects = 10, RRatio = 1)
test3 <- schema(Sites = c("AAA"), NSubjects = 30, RRatio = 2)
test4 <- schema(Sites = 2, NSubjects = 30, RRatio = 2)
test5 <- schema(Sites = c("AAA", "BBB"), NSubjects = 10, RRatio = 1)
test6 <- schema(Sites = NULL, NSubjects = 10, RRatio = 1) # Should return error
test7 <- schema(Sites = c("AAA", 1), NSubjects = 10, RRatio = 1)
tolower("HELLO world!")
test6 <- schema(Sites = NULL, NSubjects = 10, RRatio = 1) # Should return error
require("randomizeR") #package necessary for "pbrpar" function in line 33, "genSeq" in line 34, and "getRandList" in line 35
require("stringr") #package necessary for "str_pad" function in line 31
#select run to begin prompts
schema <- function(){
t <- readline("How many treatment sites to you have? ")
s <- readline("How many subjects do you have at each site? ")
b <- readline("How many subjects are in each block? ")
r <- readline("Specify a ratio for treatment to control t:c ")
sd <- readline("Set a seed number for reproducibility ")
t <- as.numeric(unlist(strsplit(t, ",")))  #t will represent number of sites
s <- as.numeric(unlist(strsplit(s, ",")))  #s will represent number of subjects at each site
b <- as.numeric(unlist(strsplit(b, ",")))  #b will represent the number of subjects in each block
r <- (unlist(strsplit(r, ":")))            #ratio will be given in form t:c, need to get "t" and "c" separately
n <- as.numeric(r[1])                      #n will represent number of treatments from ratio
d <- as.numeric(r[2])                      #d will represent number of controls from ratio
sd <- as.numeric(unlist(strsplit(sd, ",")))
df1 <- data.frame(Site=character(), Subject=integer())  #create empty data frame
sub<- seq(1:s) #list of subjects
for (i in b) {
blk<-s/b  #compute number of blocks
if (s %% b !=0 | s %% t !=0 ){
print("Enter valid parameter")    #if condition is not met, error message will occur
}
}
sub<-str_pad(sub,width=2,side="left",pad="0") #to get #'s < 10 to be of the form "0#"
bc<-rep(b,blk)    #vector that contains block size, number of blocks times
ab<-pbrPar(bc, K = 2, ratio = c(n,d), groups = c("T","C"))  #function to randomly assign treatment and control using the appropriate ratio
seq1<-genSeq(ab,t,seed=sd)   #get the random sequence generated by pbrPar function
list1 <- getRandList(seq1)
for (i in c(1:t)) {           #loop to create site names and data frame
sites<-rep(LETTERS[i],3)           #repeat letters 3 times e.g. A A A
sites<-paste(sites, collapse="")     #put letters together e.g. 'AAA'
tempdf <- data.frame(Site=as.vector(rep(sites, length(sub))),
Subject=as.vector(sub))    #create temporary data frame to store values during loop
df1 <- rbind(df1, tempdf)   #combine empty data frame with temporary data frame
}
df1$Condition=as.vector(t(getRandList(seq1)))  #add a new column to the data frame
print(df1)    #print the schema
write.csv(df1, file = "Schema.csv")
}
schema()   #prompts will begin
schema()   #prompts will begin
#select run to begin prompts
schema <- function(){
t <- readline("How many treatment sites to you have? ")
s <- readline("How many subjects do you have at each site? ")
b <- readline("How many subjects are in each block? ")
r <- readline("Specify a ratio for treatment to control t:c ")
sd <- readline("Set a seed number for reproducibility ")
t <- as.numeric(unlist(strsplit(t, ",")))  #t will represent number of sites
s <- as.numeric(unlist(strsplit(s, ",")))  #s will represent number of subjects at each site
b <- as.numeric(unlist(strsplit(b, ",")))  #b will represent the number of subjects in each block
r <- (unlist(strsplit(r, ":")))            #ratio will be given in form t:c, need to get "t" and "c" separately
n <- as.numeric(r[1])                      #n will represent number of treatments from ratio
d <- as.numeric(r[2])                      #d will represent number of controls from ratio
sd <- as.numeric(unlist(strsplit(sd, ",")))
df1 <- data.frame(Site=character(), Subject=integer())  #create empty data frame
sub<- seq(1:s) #list of subjects
for (i in b) {
blk<-s/b  #compute number of blocks
if (s %% b !=0 | s %% t !=0 ){
print("Enter valid parameter")    #if condition is not met, error message will occur
}
}
sub<-str_pad(sub,width=2,side="left",pad="0") #to get #'s < 10 to be of the form "0#"
bc<-rep(b,blk)    #vector that contains block size, number of blocks times
ab<-pbrPar(bc, K = 2, ratio = c(n,d), groups = c("T","C"))  #function to randomly assign treatment and control using the appropriate ratio
seq1<-genSeq(ab,t,seed=sd)   #get the random sequence generated by pbrPar function
list1 <- getRandList(seq1)
for (i in c(1:t)) {           #loop to create site names and data frame
sites = rep(LETTERS[i],3)           #repeat letters 3 times e.g. A A A
sites = paste(sites, collapse="")     #put letters together e.g. 'AAA'
tempdf =  data.frame(Site=as.vector(rep(sites, length(sub))),
Subject=as.vector(sub))    #create temporary data frame to store values during loop
df1 = rbind(df1, tempdf)   #combine empty data frame with temporary data frame
}
df1$Condition=as.vector(t(getRandList(seq1)))  #add a new column to the data frame
print(df1)    #print the schema
write.csv(df1, file = "Schema.csv")
}
rm(schema)
sum(NA, 1, 2, 3)
length(c(1, 2, NA))
ls <- c(1,1,1,0,0,0)
sample(ls)
sample(ls)
sample(ls)
sample(ls)
sample(ls)
sample(ls)
sample(ls, replace = FALSE)
ls <- c(1,1,1,0,0,0,1,1,0,0)
sample(ls, replace = FALSE)
rep(ls, each=10)
rep(sample(ls, replace = FALSE), each=10)
rep(sample(ls, replace = FALSE), times=10)
rep(sample(ls, replace = FALSE), times=10)
rep(rep(sample(ls, replace = FALSE), times=10), times = 3)
ls <- c(1,0,0,1,0,0,1,00)
sample(ls, replace = FALSE)
ls <- c(1,0,0,1,0,0,1,0,0)
sample(ls, replace = FALSE)
2%%1
integer(x)%%1
x%%1==0
x=3.2
x%%1==0
is.integer(2)
ls <- c(1, 2, 3, 4, 10)
ls <- c(1, 2, 3, 4, 10.2)
lapply(ls, x%%1)
lapply(ls, is.integer())
lapply(ls, is.integer)
ls <- c(1, 2, 3, 4, 10.2)
lapply(ls, is.integer)
36*2
factorial(10)/72
210/500
216/500
97/500
0.42+0.432
-0.194
0.852-0.194
0.4*0.2
0.1*0.05
0.08+0.005+0.015
typeof(1.00)
as.integer(1.20)
print(i)
for (i in 1:51){
print(i)
}
for (i in (1:51)){
print(i)
}
library(ggplot2)
library(readxl)
CleanedCalcium <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/Dr.Boyd/CleanedCalcium.xlsx",
sheet = "Sheet1")
View(CleanedCalcium)
library(ggplot2)
library(readxl)
Calcium <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/Dr.Boyd/CleanedCalcium.xlsx",
sheet = "Sheet1")
rm(CleanedCalcium)
names(Calcium)
ggplot(data = Calcium, aes(x = Sex, y = AlkPhos)) +
geom_boxplot()
ggplot(data = Calcium, aes(y = AlkPhos)) +
geom_boxplot()
ggplot(data = Calcium, aes(y = AlkPhos, group=Sex)) +
geom_boxplot()
ggplot(data = Calcium, aes(x = Sex, y = AlkPhos, fill = Sex)) +
geom_boxplot()
str(Calcium)
Calcium$Sex <- as.factor(Calcium$Sex)
Calcium$Lab <- as.factor(Calcium$Lab)
library(ggplot2)
library(readxl)
Calcium <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/Dr.Boyd/CleanedCalcium.xlsx",
sheet = "Sheet1")
View(Calcium)
names(Calcium)
str(Calcium)
Calcium$Sex <- as.factor(Calcium$Sex)
Calcium$Lab <- as.factor(Calcium$Lab)
ggplot(data = Calcium, aes(x = Sex, y = AlkPhos, fill = Sex)) +
geom_boxplot()
ggplot(data = Calcium, aes(x = Sex, y = AlkPhos, fill = Sex)) +
geom_boxplot()
ggplot(data = Calcium, aes(x = Sex, y = CamMOL, fill = Sex)) +
geom_boxplot()
ggplot(data = Calcium, aes(x = Sex, y = PhosMOL, fill = Sex)) +
geom_boxplot()
library(readxl)
customers <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/SQL Joins/joins example.xlsx",
sheet = "Customers")
View(customers)
library(readxl)
orders <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/SQL Joins/joins example.xlsx",
sheet = "Orders")
View(orders)
library(dplyr)
names(customers)
customers %>%
select(first_name, last_name) %>%
inner_join(x = customers, y = orders, by = c("customer_id"))
names(orders)
inner_join(x = customers, y = orders, by = c("customer_id"))
names(customers)
names(orders)
inner_join(x = customers, y = orders, by = c("customer_id"))
join <- inner_join(x = customers, y = orders, by = c("customer_id"))
join %>% select(first_name, last_name, order_date, amount)
left <- left_join(x = customers, y = orders, by = c("customer_id"))
left
left %>% select(first_name, last_name, order_date, amount)
outer <- merge(customers, orders, by = "customer_id", all = TRUE)
outer %>% select(first_name, last_name, order_date, amount)
merge(customers, orders, by="customers", all=customers)
customers
right <- right_join(x=customers, y=orders, by=c("customer_id"))
right
right %>% select(first_name, last_name, order_date, amount)
left_join(orders, customers, by = "customer_id")
outer <- merge(customers, orders, by = "customer_id", all = TRUE)
outer %>% select(first_name, last_name, order_date, amount)
outer %>% select(first_name, last_name, order_date, amount, order_id)
outer <- full_join(customers, orders, by="customer_id")
outer %>% select(first_name, last_name, order_date, amount, order_id)
outer <- merge(customers, orders, by = "customer_id", all = TRUE)
outer %>% select(first_name, last_name, order_date, amount, order_id)
library(readxl)
calcium <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/Dr.Boyd/CalciumGood.xlsx",
sheet = "Sheet1")
View(calcium)
library(readxl)
calcium <- read_excel("C:/Users/miqui/OneDrive/CSU Classes/Consulting/Dr.Boyd/CalciumGood.xlsx",
sheet = "Sheet1")
View(calcium)
library(ggplot2)
names(calcium)
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS)) +
geom_bar()
ggplot(data = calcium, aes(x = SEX)) +
geom_bar()
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS)) +
geom_bar(position = "dodge", stat = "identity")
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity")
calcium$SEX <- as.factor(calcium$SEX)
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity")
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
title("Comparison of Alkaline Phosphate by Gender")
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
ggtitle("Comparison of Alkaline Phosphate by Gender")
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
labs(title = "Comparison of Alkaline Phosphate by Gender")
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
labs(title = "Comparison of Alkaline Phosphate by Gender") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
labs(title = "Comparison of Alkaline Phosphate (IU/L) by Gender") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(data = calcium, aes(x = SEX, y = ALKPHOS, fill = SEX)) +
geom_bar(position = "dodge", stat = "identity") +
labs(title = "Comparison of Alkaline Phosphate (IU/L) by Gender") +
theme(plot.title = element_text(hjust = 0.5)) +
labs(x = "Gender", y = "Alkaline Phosphate (IU/L)")
BlockSize = 12
NSubjects = 48
RRatio = 3
# Adding the Ts and Cs:
blocks = block.random(n = NSubjects, ncond = BlockSize) # Create blocks first
Ts = RRatio/(RRatio+1) # Compute the number of Ts needed
Cs = 1-Ts # Compute the number of Cs needed
TorC = block_ra(blocks = blocks[ , 1], # Using the first column:
conditions = c("T", "C"), # 2 groups are the Ts and Cs
prob_each = c(Ts, Cs)) # The prob. that T or C appears
TLC = data.frame(TorC)
table(TLC)
"Read in the data and necessary libraries:"
setwd("C:/Users/miqui/OneDrive/R Projects/ADD Health")
setwd("C:/Users/miqui/OneDrive/R Projects/ADD Health")
library(dplyr)
library(lubridate)
library(rcompanion)
library(readr)
library(lavaan)
library(psych)
